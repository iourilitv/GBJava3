package lesson5.classbook;

import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * GBJava3
 * Java Core. Professional level. 19.08.2019 Webinar. Teacher: Anton Batiaev
 * Урок 5. Многопоточность. Часть II.
 * Классы для работы с многопоточностью. Concurrent collections.
 * Разбор практических примеров.
 * Интерфейс Lock. ReentrantLock().
 * Задача: Один поток листает коллекцию, а другие потоки пытаются изменить коллекцию, что приводит
 *  к ConcurrentModificationException. Поток листинга должен блокировать коллекцию до начала каждого цикла.
 * Интерфейс Lock из пакета j ava.util.concurrent – это продвинутый механизм синхронизации потоков.
 * По гибкости он выигрывает в сравнении с блоками синхронизации.
 * Основные отличия между Lock и синхронизированными блоками:
 * ● Синхронизированные блоки не гарантируют, что сохранится порядок обращения потоков к
 *   критической секции();
 * ● Нельзя выйти из синхронизированного блока по времени ожидания ( timeout );
 * ● Синхронизированные блоки должны полностью содержаться в одном методе. Lock может
 *   быть захвачен в одном методе, а освобожден в другом.
 * Методы интерфейса Lock:
 * lock() - Блокирует объект типа Lock, если это возможно. Если объект уже был заблокирован,
 *  то поток, вызвавший метод l ock(), блокируется до вызова unlock().
 * tryLock() - Метод пытается заблокировать объект типа Lock, если это возможно. При удачном
 *  блокировании вернет «true». Если же Lock уже был заблокирован – то «false», и поток,
 *  вызвавший tryLock() , не будет заблокирован.
 * tryLock(long timeout, TimeUnit timeUnit) - Похож на t ryLock(), но в течение заданного времени
 *  пытается захватить объект Lock.
 * unlock() - Разблокирует объект Lock. Вызывается только потоком, который владеет блокировкой Lock.
 *  При попытке других потоков обратиться к этому методу будет выдано исключение RuntimeException.
 */
public class LockVsSynchronize {

    public static void main(String[] args) {
        //Для работы с этим интерфейсом необходимо создать объект одной из его реализаций:
        Lock lock = new ReentrantLock();
        lock.lock();
            // критическая секция
        lock.unlock();
        //Создаем объект типа Lock и вызываем у него метод lock() – он захватывается.
        // Если другой поток попытается вызвать этот метод у того же объекта – он будет
        // блокирован до тех пор, пока поток, удерживающий объект lock, не освободит его
        // через метод unlock(). Тогда этот объект смогут захватить другие потоки.
    }
}
